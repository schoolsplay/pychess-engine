from pychessengine.constants import BRD_SQ_NUM, Pieces, Colors, Squares
from pychessengine.debug import _assert_condition
from pychessengine.helper import RAND_64

class PositionKey:
    
    """
    Represents a unique key for a chessboard position, generated by hashing pieces, castling rights,
    side to move, and en passant square. Utilizes `Zobrist hashing` to ensure efficient position lookup
    for tasks like move repetition detection.

    class variables:
        PieceKeys (list): Precomputed random values for pieces on each square.
        SideKey (int): Random value representing the side to move.
        CastleKeys (list): Random values representing castling rights.
        
    Attributes:
        key (int): Unique 64-bit HashKey

    Methods:
        _hash_piece(piece, square):
            Updates the position key by XORing the hash for a piece on a given square.

        _hash_castle(castlePerm):
            Updates the position key by XORing the hash for the current castling rights.

        _hash_side():
            Updates the position key by XORing the hash for the side to move.

        _hash_enPas(enPas):
            Updates the position key by XORing the hash for the en passant square.

        _generate_key(board):
            Generates the position key based on the board state, including pieces, side to move,
            en passant square, and castling rights.
    """
    
    PieceKeys = [[RAND_64() for _ in range(120)] for _ in range(13)]

    SideKey = RAND_64()
    CastleKeys = CastleKeys = [RAND_64() for _ in range(16)]

    def __init__(self):
        self.key = 0
        
    def copy(self):
        new_key = PositionKey()  # Create a new instance
        new_key.key = self.key   # Copy the internal state
        return new_key
        
    def _hash_piece(self, piece: int, square: int) -> None:
        self.key ^= PositionKey.PieceKeys[piece][square]
        
    def _hash_castle(self, castlePerm: int) -> None:
        self.key ^= PositionKey.CastleKeys[castlePerm]
        
    def _hash_side(self) -> None:
        self.key ^= PositionKey.SideKey
        
    def _hash_enPas(self, enPas: int) -> None:
        self.key ^= PositionKey.PieceKeys[Pieces.EMPTY][enPas]
        
    def _generate_key(self, board) -> None:
        """
        Generate a unique position key for the given board configuration.

        This function computes a hash key for the current board state, encoding
        information about piece positions, castling rights, en passant square, and 
        side to move. The generated key is stored in the `self.key` attribute, which 
        is used to uniquely represent the board state for repetition and position 
        checks in the game.

        Args:
            board: An object representing the chess board with attributes:

        """
        finalKey = 0
        piece = Pieces.EMPTY
        for sq in range(0, BRD_SQ_NUM):
            piece = board.pieces[sq]
            if(piece != Squares.OFFBOARD and piece != Pieces.EMPTY):
                _assert_condition(piece >= Pieces.wP and piece <= Pieces.bK)
                finalKey ^= PositionKey.PieceKeys[piece][sq]
        
        if(board.side == Colors.WHITE):
            finalKey ^= PositionKey.SideKey
            
        if(board.enPas != Squares.NO_SQ):
            _assert_condition(board.enPas >= 0 and board.enPas < BRD_SQ_NUM)
            finalKey ^= PositionKey.PieceKeys[Pieces.EMPTY][board.enPas]
            
        _assert_condition(board.castlePerm >= 0 and board.castlePerm <= 15)
        finalKey ^= PositionKey.CastleKeys[board.castlePerm]
        
        self.key = finalKey
